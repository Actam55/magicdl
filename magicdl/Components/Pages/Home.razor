@page "/"

<style>
    .word-wrap-box {
        flex: 0 0 200px;
        max-width: 200px;
        white-space: normal;
        word-break: break-word;
        overflow-wrap: break-word;
    }
    .dropdown-menu .dropdown-item-highlight{
        background-color: var(--bs-tertiary-bg);
    }
</style>

<PageTitle>Home</PageTitle>
@if (showSuccessAlert)
{
    <div>
        <Alert Color="AlertColor.Success">
            <h4 class="alert-heading">Congratulations!</h4>
            @if(guessHistory.Count <= 1)
            {
                <p>You correctly guessed todays card on the first try!</p>
            }
            else if (guessHistory.Count < 5)
            {
                <p>You correctly guessed todays card with only @guessHistory.Count guesses!</p>
            }
            else
            {
                <p>You correctly guessed todays card with @guessHistory.Count guesses!</p>
            }
        </Alert>
    </div>
}


<div class="d-flex p-3 justify-content-center">
    <h1 class="custom-font display-1">Magicdle</h1>
</div>



@* <p>Correct: '@correctCard.Name'</p> *@
<div container>
    <div class="row d-flex p-3 justify-content-center align-items-center ">
        @if (hintGotten)
            {
            <div class="col-md-3 border rounded fw-bold p-3 me-3 d-flex justify-content-center align-items-center">
                <p>
                    Hint: @correctCard.Oracle_Text
                </p>
            </div>
        }
        <div class="col-md-1">
            <Button @onclick="GetHint" class="btn btn-primary">Get a hint</Button>
        </div>
        <div class="col-md-3">
            <AutoComplete @bind-Value="currentGuessString" 
                TItem="MTGCard" 
                DataProvider="CardListProvider" 
                PropertyName="Name" 
                Placeholder="Search for a card" 
                OnChanged="(MTGCard card) => OnAutoCompleteChanged(card)"
                Disabled="@disabled"
                Size="AutoCompleteSize.Large" />
        </div>
    </div>
</div>

<div class="container text-center">
    <div class="row mb-2 p-3 me-3 justify-content-center">
        <div class="col border rounded fw-bold p-3 me-3">
            Card Image
        </div>
        <div class="col border rounded fw-bold p-3 me-3">
            Card Name
        </div>
        <div class="col border rounded fw-bold p-3 me-3">
            Card Type
        </div>
        <div class="col border rounded fw-bold p-3 me-3">
            Identification
        </div>
        <div class="col border rounded fw-bold p-3 me-3">
            Keywords
        </div>
        <div class="col border rounded fw-bold p-3 me-3">
            Release Date
        </div>
        <div class="col border rounded fw-bold p-3 me-3">
            CMC
        </div>
    </div>
</div>

<div class="container text-center">
    @foreach (MTGCard guess in guessHistory)
    {
        <div class="row p-3 me-3 justify-content-center">
            <div class="col border rounded fw-bold p-3 me-3 d-flex justify-content-center align-items-center">
                <img src="@guess.ImageUrl" style="max-width: 130px;" />
            </div>
            <div class="col border rounded fw-bold p-3 me-3 d-flex justify-content-center align-items-center @(guess.Name.Equals(correctCard.Name, StringComparison.OrdinalIgnoreCase) ? "bg-success" : "bg-danger")">@guess.Name </div>
            <div class="col border rounded fw-bold p-3 me-3 d-flex justify-content-center align-items-center @MatchLevelToCssClass(GetMatchLevel(guess.Type, correctCard.Type))">@string.Join(", ", guess.Type)</div>
            <div class="col border rounded fw-bold p-3 me-3 d-flex justify-content-center align-items-center @MatchLevelToCssClass(GetMatchLevel(guess.Color, correctCard.Color))">@string.Join(", ", guess.Color)</div>
            <div class="col border rounded fw-bold p-3 me-3 d-flex justify-content-center align-items-center @MatchLevelToCssClass(GetMatchLevel(guess.Keywords, correctCard.Keywords))">@string.Join(", ", guess.Keywords)</div>
            <div class="col border rounded fw-bold p-3 me-3 d-flex justify-content-center align-items-center @(guess.ReleaseDate?.Year == correctCard.ReleaseDate?.Year ? "bg-success" : "bg-danger")">
                @if (guess.ReleaseDate.HasValue)
                {
                    @guess.ReleaseDate.Value.Year
                    @if (guess.ReleaseDate.Value.Year < correctCard.ReleaseDate?.Year)
                    {
                        <span>⬆️</span> <!-- Guessed card is from an earlier year -->
                    }
                    else if (guess.ReleaseDate.Value.Year > correctCard.ReleaseDate?.Year)
                    {
                        <span>⬇️</span> <!-- Guessed card is from a later year -->
                    }
                    else
                    {
                    }
                }
            </div>
            <div class="col border rounded fw-bold p-3 me-3 d-flex justify-content-center align-items-center @(guess.CMC == correctCard.CMC ? "bg-success" : "bg-danger")">
                @guess.CMC
                @if (guess.CMC < correctCard.CMC)
                {
                    <span>⬆️</span> <!-- Guessed card has lower CMC -->
                }
                else if (guess.CMC > correctCard.CMC)
                {
                    <span>⬇️</span> <!-- Guessed card has higher CMC -->
                }
                else
                {
                }
            </div>
        </div>
    }
</div>

@code {
    private List<MTGCard> cardList = new List<MTGCard>();
    private List<MTGCard> guessHistory = new List<MTGCard>();
    private MTGCard currentGuess = new MTGCard();
    private MTGCard correctCard = new MTGCard();
    private string currentGuessString = string.Empty;
    private HttpResponseMessage response = new HttpResponseMessage();
    private string json = string.Empty;
    private int cardsFound;
    private List<string> keywords = new List<string>();
    private bool disabled = false;
    private bool showSuccessAlert = false;
    private bool hintGotten = false;

    public enum MatchLevel
    {
        None,
        Partial,
        Full
    }

    private async Task<AutoCompleteDataProviderResult<MTGCard>> CardListProvider(AutoCompleteDataProviderRequest<MTGCard> request)
    {
        string filterText = request.Filter.Value;
        Console.WriteLine($"User typed: {filterText}");

        var filteredCardList = cardList
            .Where(card => card.Name.Contains(filterText, StringComparison.OrdinalIgnoreCase))
            .OrderBy(card =>
            {
                var name = card.Name;

                if (name.Equals(filterText, StringComparison.OrdinalIgnoreCase))
                    return 0;
                else if (name.StartsWith(filterText, StringComparison.OrdinalIgnoreCase))
                    return 1;
                else if (name.IndexOf(filterText, StringComparison.OrdinalIgnoreCase) >= 0)
                    return 2;
                else
                    return 3;
            })
            .ThenBy(card =>
            {
                // Secondary sort by index of match, so 'Bolt' appears before 'Firebolt' if search is 'bolt'
                int index = card.Name.IndexOf(filterText, StringComparison.OrdinalIgnoreCase);
                return index == -1 ? int.MaxValue : index;
            })
            .ThenBy(card => card.Name) // Final fallback alphabetical
            .ToList();

        return await Task.FromResult(request.ApplyTo(filteredCardList));
    }

    private void OnAutoCompleteChanged(MTGCard card)
    {
        if (card is null || string.IsNullOrEmpty(card.Name))
        {
            // Display message or toast
            Console.WriteLine("Card not found.");
            return;
        }

        currentGuess = card;
        guessHistory.Insert(0, currentGuess);
        cardList.Remove(currentGuess);
        currentGuessString = string.Empty;
        if(currentGuess.Name == correctCard.Name)
        {
            disabled = true;
            showSuccessAlert = true;
        }
    }

    public MatchLevel GetMatchLevel(List<string> guessList, List<string> correctList)
    {
        if (guessList == null || correctList == null || guessList.Count == 0)
            return MatchLevel.None;

        bool exactMatch = guessList.All(item => correctList.Contains(item))
               && correctList.All(item => guessList.Contains(item));
        bool anyMatch = guessList.Any(item => correctList.Contains(item));

        if (exactMatch)
            return MatchLevel.Full;
        else if (anyMatch)
            return MatchLevel.Partial;
        else
            return MatchLevel.None;
    }

    public string MatchLevelToCssClass(MatchLevel level) => level switch
    {
        MatchLevel.Full => "bg-success",
        MatchLevel.Partial => "bg-warning",
        _ => "bg-danger"
    };

    public void CardGuessChanged(string value)
    {
        currentGuess = SetCard(value);
        if (string.IsNullOrEmpty(currentGuess.Name))
        {
            //Give a message that the card was not found.
            return;
        }

        guessHistory.Insert(0, currentGuess);
        currentGuessString = string.Empty;

        StateHasChanged();
    }

    public MTGCard SetCard(string? value)
    {
        if (string.IsNullOrEmpty(value))
        {
            return new MTGCard();
        }

        foreach (MTGCard card in cardList)
        {
            if (value.Equals(card.Name, StringComparison.OrdinalIgnoreCase))
            {
                return card;
            }
        }
        return new MTGCard();
    }

    public async Task GetCardListAsync()
    {
        guessHistory = new List<MTGCard>();
        cardList = new List<MTGCard>();
        Random rnd = new Random();
        HttpClient client = new HttpClient();
        client.DefaultRequestHeaders.UserAgent.ParseAdd("Magicdl/1.0");
        client.DefaultRequestHeaders.Accept.ParseAdd(("application/json;q=0.9,*/*;q=0.8"));
        response = await client.GetAsync("https://api.scryfall.com/cards/search?order=edhrec&dir=asc&q=id%3Awubrg+-t=land+prefer%3Aoldest&page=1");
        json = await response.Content.ReadAsStringAsync();

        using (JsonDocument document = JsonDocument.Parse(json))
        {
            JsonElement root = document.RootElement;
            foreach (JsonElement cardElement in root.GetProperty("data").EnumerateArray())
            {
                MTGCard card = new MTGCard();
                card.Name = cardElement.GetProperty("name").GetString();
                card.CMC = cardElement.GetProperty("cmc").GetDouble();
                string typeLine = cardElement.GetProperty("type_line").GetString();
                string beforeDash = typeLine.Split('—')[0].Trim();
                card.Type = beforeDash.Split(' ').ToList();
                card.Color = cardElement.GetProperty("color_identity").EnumerateArray().Select(c => c.GetString()).ToList();
                if(card.Color.Count == 0)
                {
                    card.Color.Add("Colorless");
                }
                string releaseDateStr = cardElement.GetProperty("released_at").GetString();
                if (DateOnly.TryParse(releaseDateStr, out DateOnly parsedDate))
                {
                    card.ReleaseDate = parsedDate;
                }
                else
                {
                    card.ReleaseDate = null;
                }
                if (cardElement.TryGetProperty("keywords", out JsonElement keywordsElement))
                {
                    List<string?> keywords = keywordsElement.EnumerateArray().Select(k => k.GetString()).Where(k => !string.IsNullOrEmpty(k)).ToList();

                    card.Keywords = keywords.Any() ? keywords : new List<string> { "None" };
                }
                else
                {
                    card.Keywords = new List<string> { "None" };
                }


                card.Oracle_Text = cardElement.GetProperty("oracle_text").GetString();

                if (cardElement.TryGetProperty("image_uris", out JsonElement imageUris))
                {
                    if (imageUris.TryGetProperty("art_crop", out JsonElement imageUrl))
                    {
                        card.ImageUrl = imageUrl.GetString();
                    }
                }
                cardList.Add(card);
            }
        }
        cardsFound = cardList.Count();
        int randomIndex = rnd.Next(0, cardList.Count);
        correctCard = cardList[randomIndex];
        hintGotten = false;
        keywords = correctCard.Keywords;
    }

    void GetHint()
    {
        hintGotten = true;
    }
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await GetCardListAsync();
        }
    }

}