@page "/"
@inject IJSRuntime JS

<style>
    .word-wrap-box {
        flex: 0 0 200px;
        max-width: 200px;
        white-space: normal;
        word-break: break-word;
        overflow-wrap: break-word;
    }
    .dropdown-menu .dropdown-item-highlight{
        background-color: var(--bs-tertiary-bg);
    }
</style>

<PageTitle>Home</PageTitle>

<Modal @ref='modal'> @* Victory Component *@
    <BodyTemplate>
        <div class="row d-flex p-3 justify-content-center text-center">
            <h3 class="custom-font"> Congratulations! </h3>
        </div>
        @if(guessHistory.Count() == 1)
        {
            <div class=" row d-flex p-3 justify-content-center text-center">
                <h3 class="custom-font"> You guessed the correct card on you first try! </h3>
            </div>
        }
        else{
            <div class=" row d-flex p-3 justify-content-center text-center">
                <h3 class="custom-font"> You guessed the correct card with @guessHistory.Count() guesses! </h3>
            </div>
        }
        <div class="row d-flex p-3 justify-content-center align-items-center">
            <img src="@correctCard.FullCardImage" />
        </div>
    </BodyTemplate>
</Modal>

@if (isLoading) @* Loading *@
{
    <div class="position-absolute start-0 m-3 spinner-border text-primary" role="status">
        <span class="visually-hidden">Loading...</span>
    </div>
}

<div class="position-absolute end-0 m-3" @ref="settingsMenuRef"> @* Settings *@
    <div class="dropdown">
        <button class="btn btn-secondary dropdown-toggle" @onclick="ToggleSettingsMenu">
            ⚙️ Settings
        </button>
        @if (settingsMenuOpen)
        {
            <div class="dropdown-menu dropdown-menu-end show">
                <button class="dropdown-item" @onclick="() => ToggleTheme()">Toggle Theme</button>
                <div class="dropdown-item">
                    Difficulty:
                    <select value="@nrOfPagesToGet" @onchange="OnDifficultyChanged" class="form-select mt-1">
                        <option value="1">Easy</option>
                        <option value="3">Medium</option>
                        <option value="6">Hard</option>
                    </select>
                </div>
            </div>
        }
    </div>
</div>
<div class="d-flex p-3 justify-content-center"> @* Title *@
    <h1 class="custom-font display-1">Magicdle</h1>
</div>

@if (currentGuess == correctCard)@* Play again*@
{
    <div class="d-flex p-3 justify-content-center">
        <Button @onclick="PlayAgain" class="btn btn-success" Size="ButtonSize.Large"> Play Again!</Button>
    </div>
}

<p>Correct: '@correctCard.Name'</p>
<p>Cards Gotten: '@cardCount'</p>
<div container> @* Hint and Search *@
    <div class="row d-flex p-3 justify-content-center align-items-center ">
        @if (hintGotten)
            {
            <div class="col-md-3 border rounded fw-bold p-3 me-3 d-flex justify-content-center align-items-center">
                <p>
                    Hint: @correctCard.Oracle_Text
                </p>
            </div>
        }
        <div class="col-md-1">
            <Button @onclick="GetHint" class="btn btn-primary">Get a Hint</Button>
        </div>
        <div class="col-md-3">
            <AutoComplete @bind-Value="currentGuessString" 
                TItem="MTGCard" 
                DataProvider="CardListProvider" 
                PropertyName="Name" 
                Placeholder="Search for a card" 
                OnChanged="(MTGCard card) => OnAutoCompleteChanged(card)"
                Disabled="@(disabled || isLoading)"
                Size="AutoCompleteSize.Large" />
        </div>
    </div>
</div>

<div class="container text-center"> @* Card Identifiers *@
    <div class="row mb-2 p-3 me-3 justify-content-center">
        <div class="col border rounded fw-bold p-3 me-3">
            Card
        </div>
        <div class="col border rounded fw-bold p-3 me-3">
            Card Type
        </div>
        <div class="col border rounded fw-bold p-3 me-3">
            Identification
        </div>
        <div class="col border rounded fw-bold p-3 me-3">
            Keywords
        </div>
        <div class="col border rounded fw-bold p-3 me-3">
            Release Date
        </div>
        <div class="col border rounded fw-bold p-3 me-3">
            CMC
        </div>
    </div>
</div>

<div class="container text-center"> @* Card Guesses *@
    @foreach (MTGCard guess in guessHistory)
    {
        <div class="row p-3 me-3 justify-content-center">
            <div class="col border rounded fw-bold p-3 me-3 d-flex flex-column justify-content-center align-items-center @(guess.Name.Equals(correctCard.Name, StringComparison.OrdinalIgnoreCase) ? "bg-success" : "bg-danger")">
                <div class="text-center mb-2">@guess.Name</div>
                <img src="@guess.ImageUrl" style="max-width: 130px;" class="img-fluid rounded" />
            </div>
            <div class="col border rounded fw-bold p-3 me-3 d-flex justify-content-center align-items-center @MatchLevelToCssClass(GetMatchLevel(guess.Type, correctCard.Type))">@string.Join(", ", guess.Type)</div>
            <div class="col border rounded fw-bold p-3 me-3 d-flex justify-content-center align-items-center @MatchLevelToCssClass(GetMatchLevel(guess.Color, correctCard.Color))">@string.Join(", ", guess.Color)</div>
            <div class="col border rounded fw-bold p-3 me-3 d-flex justify-content-center align-items-center @MatchLevelToCssClass(GetMatchLevel(guess.Keywords, correctCard.Keywords))">@string.Join(", ", guess.Keywords)</div>
            <div class="col border rounded fw-bold p-3 me-3 d-flex justify-content-center align-items-center @(guess.ReleaseDate?.Year == correctCard.ReleaseDate?.Year ? "bg-success" : "bg-danger")">
                @if (guess.ReleaseDate.HasValue)
                {
                    @guess.ReleaseDate.Value.Year
                    @if (guess.ReleaseDate.Value.Year < correctCard.ReleaseDate?.Year)
                    {
                        <span>⬆️</span>
                    }
                    else if (guess.ReleaseDate.Value.Year > correctCard.ReleaseDate?.Year)
                    {
                        <span>⬇️</span>
                    }
                    else
                    {
                    }
                }
            </div>
            <div class="col border rounded fw-bold p-3 me-3 d-flex justify-content-center align-items-center @(guess.CMC == correctCard.CMC ? "bg-success" : "bg-danger")">
                @guess.CMC
                @if (guess.CMC < correctCard.CMC)
                {
                    <span>⬆️</span>
                }
                else if (guess.CMC > correctCard.CMC)
                {
                    <span>⬇️</span>
                }
                else
                {
                }
            </div>
        </div>
    }
</div>

@code {
    private List<MTGCard> cardList = new List<MTGCard>();
    private List<MTGCard> guessHistory = new List<MTGCard>();
    private MTGCard currentGuess = new MTGCard();
    private MTGCard correctCard = new MTGCard();
    private string currentGuessString = string.Empty;
    private HttpResponseMessage response = new HttpResponseMessage();
    private string json = string.Empty;
    private bool disabled = false;
    private bool isLoading = false;
    private bool hintGotten = false;
    private bool settingsMenuOpen = false;
    private string currentTheme = "dark";
    private ElementReference settingsMenuRef;
    private Modal modal = default!;
    private int cardCount;
    private int nrOfPagesToGet = 1;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await GetCardListAsync();
        }
    }

    public async Task PlayAgain()
    {
        isLoading = true;
        await GetCardListAsync();
        isLoading = false;
        disabled = false;
    }

    private async Task OnDifficultyChanged(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out int pages))
        {
            nrOfPagesToGet = pages;
            isLoading = true;
            await GetCardListAsync();
            isLoading = false;
            disabled = false;
        }
    }

    public enum MatchLevel
    {
        None,
        Partial,
        Full
    }

    private async Task<AutoCompleteDataProviderResult<MTGCard>> CardListProvider(AutoCompleteDataProviderRequest<MTGCard> request)
    {
        string filterText = request.Filter.Value;
        Console.WriteLine($"User typed: {filterText}");

        var filteredCardList = cardList
            .Where(card => card.Name.Contains(filterText, StringComparison.OrdinalIgnoreCase))
            .OrderBy(card =>
            {
                var name = card.Name;

                if (name.Equals(filterText, StringComparison.OrdinalIgnoreCase))
                    return 0;
                else if (name.StartsWith(filterText, StringComparison.OrdinalIgnoreCase))
                    return 1;
                else if (name.IndexOf(filterText, StringComparison.OrdinalIgnoreCase) >= 0)
                    return 2;
                else
                    return 3;
            })
            .ThenBy(card =>
            {
                // Secondary sort by index of match, so 'Bolt' appears before 'Firebolt' if search is 'bolt'
                int index = card.Name.IndexOf(filterText, StringComparison.OrdinalIgnoreCase);
                return index == -1 ? int.MaxValue : index;
            })
            .ThenBy(card => card.Name) // Final fallback alphabetical
            .ToList();

        return await Task.FromResult(request.ApplyTo(filteredCardList));
    }

    private async Task OnAutoCompleteChanged(MTGCard card)
    {
        if (card is null || string.IsNullOrEmpty(card.Name))
        {
            // Display message or toast
            Console.WriteLine("Card not found.");
        }
        else
        {
            currentGuess = card;
            guessHistory.Insert(0, currentGuess);
            cardList.Remove(currentGuess);
            currentGuessString = string.Empty;
            if(currentGuess.Name == correctCard.Name)
            {
                disabled = true;
                await modal.ShowAsync();
            }
        }
    }

    public MatchLevel GetMatchLevel(List<string> guessList, List<string> correctList)
    {
        if (guessList == null || correctList == null || guessList.Count == 0)
            return MatchLevel.None;

        bool exactMatch = guessList.All(item => correctList.Contains(item))
               && correctList.All(item => guessList.Contains(item));
        bool anyMatch = guessList.Any(item => correctList.Contains(item));

        if (exactMatch)
            return MatchLevel.Full;
        else if (anyMatch)
            return MatchLevel.Partial;
        else
            return MatchLevel.None;
    }

    public string MatchLevelToCssClass(MatchLevel level) => level switch
    {
        MatchLevel.Full => "bg-success",
        MatchLevel.Partial => "bg-warning",
        _ => "bg-danger"
    };

    public void CardGuessChanged(string value)
    {
        currentGuess = SetCard(value);
        if (string.IsNullOrEmpty(currentGuess.Name))
        {
            //Give a message that the card was not found.
            return;
        }
        else
        {
            guessHistory.Insert(0, currentGuess);
            currentGuessString = string.Empty;

            StateHasChanged();
        }
    }

    public MTGCard SetCard(string? value)
    {
        if (string.IsNullOrEmpty(value))
        {
            return new MTGCard();
        }

        foreach (MTGCard card in cardList)
        {
            if (value.Equals(card.Name, StringComparison.OrdinalIgnoreCase))
            {
                return card;
            }
        }
        return new MTGCard();
    }

    public async Task GetCardListAsync()
    {
        guessHistory = new List<MTGCard>();
        cardList = new List<MTGCard>();
        Random rnd = new Random();
        HttpClient client = new HttpClient();
        client.DefaultRequestHeaders.UserAgent.ParseAdd("Magicdl/1.0");
        client.DefaultRequestHeaders.Accept.ParseAdd(("application/json;q=0.9,*/*;q=0.8"));

        for (int i = 1; i <= nrOfPagesToGet; i++)
        {
            response = await client.GetAsync($"https://api.scryfall.com/cards/search?order=edhrec&dir=asc&q=id%3Awubrg+-t=land+prefer%3Aoldest&page={i}");
            json = await response.Content.ReadAsStringAsync();

            using (JsonDocument document = JsonDocument.Parse(json))
            {
                JsonElement root = document.RootElement;
                foreach (JsonElement cardElement in root.GetProperty("data").EnumerateArray())
                {
                    MTGCard card = new MTGCard();
                    if (cardElement.TryGetProperty("name", out JsonElement nameElement))
                    {
                        card.Name = nameElement.GetString();
                    }
                    else
                    {
                        card.Name = "Unknown"; // Or handle it appropriately
                    }
                    if (cardElement.TryGetProperty("cmc", out JsonElement cmcElement))
                    {
                        card.CMC = cmcElement.GetDouble();
                    }
                    else
                    {
                        card.CMC = null; // Or another default/fallback value
                    }
                    if (cardElement.TryGetProperty("type_line", out JsonElement typeLineElement))
                    {
                        string typeLine = typeLineElement.GetString() ?? "";
                        string beforeDash = typeLine.Split('—')[0].Trim();
                        card.Type = beforeDash.Split(' ').ToList();
                    }
                    else
                    {
                        card.Type = new List<string> { "Unknown" };
                    }
                    card.Color = cardElement.GetProperty("color_identity").EnumerateArray().Select(c => c.GetString()).ToList();
                    if(card.Color.Count == 0)
                    {
                        card.Color.Add("Colorless");
                    }
                    string releaseDateStr = cardElement.GetProperty("released_at").GetString();
                    
                    if (DateOnly.TryParse(releaseDateStr, out DateOnly parsedDate))
                    {
                        card.ReleaseDate = parsedDate;
                    }
                    else
                    {
                        card.ReleaseDate = null;
                    }
                    
                    if (cardElement.TryGetProperty("keywords", out JsonElement keywordsElement))
                    {
                        List<string?> keywords = keywordsElement.EnumerateArray().Select(k => k.GetString()).Where(k => !string.IsNullOrEmpty(k)).ToList();

                        card.Keywords = keywords.Any() ? keywords : new List<string> { "None" };
                    }
                    else
                    {
                        card.Keywords = new List<string> { "None" };
                    }

                    if (cardElement.TryGetProperty("oracle_text", out JsonElement oracleTextElement))
                    {
                        card.Oracle_Text = oracleTextElement.GetString();
                    }
                    else
                    {
                        card.Oracle_Text = "";
                    }

                    if (cardElement.TryGetProperty("image_uris", out JsonElement imageUris))
                    {
                        if (imageUris.TryGetProperty("art_crop", out JsonElement imageUrl))
                        {
                            card.ImageUrl = imageUrl.GetString();
                        }
                        if (imageUris.TryGetProperty("border_crop", out JsonElement FullCardImage))
                        {
                            card.FullCardImage = FullCardImage.GetString();
                        }
                    }
                    cardList.Add(card);
                }
            }
        }
        int randomIndex = rnd.Next(0, cardList.Count);
        correctCard = cardList[randomIndex];
        hintGotten = false;
        cardCount = cardList.Count();
    }

    void GetHint()
    {
        hintGotten = true;
    }

    private async Task ToggleSettingsMenu()
    {
        settingsMenuOpen = !settingsMenuOpen;

        if (settingsMenuOpen)
        {
            await JS.InvokeVoidAsync("registerOutsideClickHandler", settingsMenuRef, DotNetObjectReference.Create(this));
        }
        else
        {
            await JS.InvokeVoidAsync("unregisterOutsideClickHandler");
        }
    }

    private async Task ToggleTheme()
    {
        currentTheme = currentTheme == "dark" ? "light" : "dark";
        await JS.InvokeVoidAsync("setTheme", currentTheme);
    }

    [JSInvokable]
    public async Task CloseSettingsMenu()
    {
        settingsMenuOpen = false;
        await InvokeAsync(StateHasChanged);
        await JS.InvokeVoidAsync("unregisterOutsideClickHandler");
    }
}